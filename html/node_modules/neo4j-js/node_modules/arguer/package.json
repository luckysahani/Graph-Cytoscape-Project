{
  "name": "arguer",
  "version": "0.0.1",
  "author": {
    "name": "Bret Copeland",
    "email": "bret@atlantisflight.org"
  },
  "description": "Normalizes arguments for JavaScript functions with optional arguments and provides optional typing.",
  "main": "./arguer.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/bretcope/arguer.git"
  },
  "dependencies": {},
  "devDependencies": {},
  "keywords": [
    "argument",
    "parameter",
    "overload",
    "function",
    "normalize",
    "optional"
  ],
  "analyze": false,
  "license": "MIT",
  "readme": "# Arguer\r\n\r\nArguer normalizes arguments for JavaScript functions with optional arguments and provides optional typing.\r\n\r\nYou could think of Arguer as a crude way to help implement function overloading, but it takes a different approach from other function overloading libraries and focuses more on handling optional parameters than traditional overloading.\r\n\r\n## Installation\r\n\r\n```\r\nnpm install arguer\r\n```\r\n\r\n... or `npm install --save arguer` if you want arguer added to your `package.json` automatically.\r\n\r\n## Simple Example\r\n\r\nA function's _arguments_ and a _format array_ are passed to the `arguer` function which returns a normalized object.   \r\n\r\n```javascript\r\nvar arguer = require('./arguer.js');\r\n\r\nvar _testFormat = ['a', {name: 'b', optional: true}, 'c'];\r\nfunction test (a, b, c) {\r\n  var args = arguer(arguments, _testFormat);\r\n  console.log(args);\r\n}\r\n\r\ntest('hello', 'world');\r\n```\r\n\r\nOutputs:\r\n\r\n```javascript\r\n{ a: 'hello', b: undefined, c: 'world' }\r\n```\r\n\r\n> Note that `_testFormat` was declared outside the function which uses it. This is obviously not necessary, but there is a performance benefit to reusing a format array, not only because there is no overhead incurred in creating and garbage collecting an array, but also because Arguer won't have to re-count how many optional arguments exist every time the function is called.\r\n\r\nThis would have been roughly equivalent to the following code:\r\n\r\n```javascript\r\nfunction test (a, b, c) {\r\n  if (arguments.length < 3) {\r\n    c = b;\r\n    b = undefined;\r\n  }\r\n  console.log({a: a, b: b, c: c});\r\n}\r\n```\r\n\r\nWith only one or two occasional optional arguments, it is not difficult to handle this with your own code such as above. Much of Arguer's usefulness comes from its ability to handle more complicated scenarios.\r\n\r\n## Format Array\r\n\r\nIn the [simple example](#simple-example) above, we used\r\n\r\n```javascript\r\n['a', {name: 'b', optional: true}, 'c']\r\n```\r\n\r\nas our format array. It says `a` and `c` are required, and `b` is optional. Each element of the format array is either a string representing a required argument of any type, or an object which describes the accepted argument in more detail. These objects must contain the 'name' property. All other properties are optional.\r\n\r\n### Properties\r\n\r\n#### name : _string_\r\n\r\nThe name of the argument.\r\n\r\n#### optional : _boolean_\r\n\r\nIf true, the argument will be considered optional.\r\n\r\n#### type : _string_\r\n\r\nIf supplied `typeof` will be used to assess whether an argument is a match.\r\n\r\n#### nType : _string_\r\n\r\nWorks opposite of type. In other words, an argument must not match this type in order to match.\r\n\r\n#### instance : _Function_\r\n\r\nSimilar to type, except instanceof is used for comparison instead of typeof.\r\n\r\n#### nInstance : _Function_\r\n\r\nOpposite of instance.\r\n\r\n### Back-Reference Properties\r\n\r\nEach of the following properties accept a string which represents the name of a previous argument. ___Only previous___ arguments can referenced. In other words, arg with index 4 can reference any arg 0 through 3, but cannot reference arg 5. If any one or more of the following properties are used, optional:true is implied, and can be omitted.\r\n\r\n#### requires : _string_\r\n\r\nThe name of a preceding argument which must have been fulfilled in order for the current argument to be considered.\r\n\r\n#### requiredBy : _string_\r\n\r\nThe name of a preceding argument which, if fulfiled, causes the current argument to be required instead of optional.\r\n\r\n#### mutex : _string_\r\n\r\nEssentially the opposite of requires&requiredBy. If the named argument was fulfilled, then the current argument will not be considered.\r\n\r\n## Matching Algorithm\r\n\r\nIt is important to understand that the matching algorithm evaluates arguments in order. It makes no attempt to find the \"best\" match for a format. If we modified our original simple example to make the `c` argument optional with `type: 'string'`\r\n\r\n```javascript\r\nvar _testFormat = ['a', {name: 'b', optional: true}, {name: 'c', optional: true, type: 'string'}];\r\nfunction test (a, b, c) {\r\n  var args = arguer(arguments, _testFormat);\r\n  console.log(args);\r\n}\r\n\r\ntest('hello', 'world');\r\n```\r\n\r\nwe might intuitively think `'world'` would be a better fit for argument `c` since it's a string; however, it be assigned to argument `b` because arguments are evaluated in-order and `b` can match anything. Therefore, this will output:\r\n\r\n```javascript\r\n{ a: 'hello', b: 'world', c: undefined }\r\n```\r\n\r\nIf we _really_ want `c` to handle strings, and `b` to handle anything else, we could reorder the arguments so `c` comes first, or we could use [nType](#ntype) and apply `nType: 'string'` to `b`.\r\n\r\n## Errors\r\n\r\nIf the arguments provided cannot be matched according to the rules of the format array, an `Error` object is returned instead of a normal object. This can be checked using the `instanceof` operator.\r\n\r\n```javascript\r\nfunction test (a, b, c) {\r\n   var args = arguer(arguments, ['a', 'b', 'c']);\r\n   if (args instanceof Error) {\r\n     console.log(args.message);\r\n     return;\r\n   }\r\n}\r\n\r\ntest('hello', 'world');\r\n```\r\n\r\nOutputs:\r\n\r\n```\r\nNot enough arguments provided.\r\n```\r\n\r\n## Additional Examples\r\n\r\nArguer was originally built as part of [neo4j-js](https://github.com/bretcope/neo4j-js), and, until more examples are added to this readme, it is probably the best source for examples.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bretcope/arguer/issues"
  },
  "_id": "arguer@0.0.1",
  "dist": {
    "shasum": "c147d2732ddceef36a64a3d997cc1a9feba6af3e"
  },
  "_from": "arguer@0.0.1",
  "_resolved": "https://registry.npmjs.org/arguer/-/arguer-0.0.1.tgz"
}
